/**
 * Alias Generator
 * 
 * Generates shell aliases for Claude Code providers.
 * Enhanced with security validation, error handling, and shell compatibility.
 */

const fs = require('fs-extra');
const path = require('path');

class AliasGenerator {
  constructor(configDir) {
    this.configDir = configDir;
    this.providersDir = path.join(configDir, 'providers');
    this.aliasesFile = path.join(configDir, 'aliases.sh');
    this.lockFile = path.join(configDir, '.alias-lock');
    
    // Security and validation settings
    this.maxAliasLength = 32;
    this.version = '2.0.0';
    
    // Shell compatibility detection
    this.shellType = this._detectShell();
  }

  /**
   * Generate aliases for all configured providers with enhanced security
   */
  async generateAliases() {
    try {
      await this._acquireLock('generate');
      
      // Load and validate providers
      const providers = await this.loadProviders();
      await this._validateProviders(providers);
      
      // Generate alias content
      const aliasContent = this.buildAliasContent(providers);
      
      // Create backup of existing aliases file
      await this._backupExistingAliases();
      
      // Write new aliases file with secure permissions
      await fs.writeFile(this.aliasesFile, aliasContent, { mode: 0o644 });
      
      // Verify the generated file
      await this._verifyAliasesFile();
      
      await this._releaseLock();
      
    } catch (error) {
      await this._releaseLock();
      throw new Error(`Failed to generate aliases: ${error.message}`);
    }
  }

  /**
   * Load all provider configurations
   */
  async loadProviders() {
    try {
      if (!await fs.pathExists(this.providersDir)) {
        return [];
      }

      const files = await fs.readdir(this.providersDir);
      const providers = [];

      for (const file of files) {
        if (path.extname(file) === '.json') {
          try {
            const provider = await fs.readJson(path.join(this.providersDir, file));
            if (provider && provider.alias) {
              providers.push(provider);
            }
          } catch (error) {
            console.warn(`Warning: Failed to read provider file ${file}: ${error.message}`);
          }
        }
      }

      return providers.sort((a, b) => a.alias.localeCompare(b.alias));
    } catch (error) {
      console.warn(`Warning: Failed to load providers: ${error.message}`);
      return [];
    }
  }

  /**
   * Build the complete alias file content
   */
  buildAliasContent(providers) {
    const header = this.generateHeader();
    const helperFunctions = this.generateHelperFunctions();
    const aliases = this.generateProviderAliases(providers);
    const footer = this.generateFooter(providers);

    return [header, helperFunctions, aliases, footer].join('\n\n');
  }

  /**
   * Generate file header
   */
  generateHeader() {
    return `# Claude Code Kit - Auto-generated aliases
# This file is automatically generated. Do not edit manually.
# Generated on: ${new Date().toISOString()}
#
# Usage:
#   Source this file in your shell configuration (.zshrc, .bashrc)
#   Each provider creates an alias that loads the appropriate configuration
#
# Example:
#   claude "Hello, how are you?"    # Uses default provider
#   cc "Explain React hooks"        # Uses custom provider if configured`;
  }

  /**
   * Generate enhanced helper functions with better error handling
   */
  generateHelperFunctions() {
    return `# Claude Code Kit Helper Functions v${this.version}
# Shell: ${this.shellType}
# Generated: ${new Date().toISOString()}

# Enhanced helper function to load Claude configuration
_cc_load_config() {
    local config_file="$1"
    local provider_alias="$2"
    
    # Validate input parameters
    if [ -z "$config_file" ]; then
        echo "Error: No configuration file specified" >&2
        return 1
    fi
    
    if [ ! -f "$config_file" ]; then
        echo "Error: Provider configuration not found: $config_file" >&2
        echo "Run 'cc-config provider list' to see available providers" >&2
        return 1
    fi
    
    # Check file permissions for security
    local file_perms=$(stat -c "%a" "$config_file" 2>/dev/null || stat -f "%A" "$config_file" 2>/dev/null)
    if [ "$file_perms" != "600" ] && [ "$file_perms" != "644" ]; then
        echo "Warning: Provider configuration file has unusual permissions: $file_perms" >&2
    fi
    
    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for Claude Code Kit but not installed" >&2
        echo "Installation instructions:" >&2
        echo "  macOS:   brew install jq" >&2
        echo "  Ubuntu:  sudo apt-get install jq" >&2
        echo "  CentOS:  sudo yum install jq" >&2
        return 1
    fi
    
    # Load and validate configuration
    local json_content
    if ! json_content=$(cat "$config_file" 2>/dev/null); then
        echo "Error: Unable to read configuration file: $config_file" >&2
        return 1
    fi
    
    if ! echo "$json_content" | jq . >/dev/null 2>&1; then
        echo "Error: Invalid JSON in configuration file: $config_file" >&2
        echo "Run 'cc-config provider edit $provider_alias' to fix the configuration" >&2
        return 1
    fi
    
    # Extract configuration values
    local api_key=$(echo "$json_content" | jq -r ".apiKey // empty")
    local base_url=$(echo "$json_content" | jq -r ".baseURL // empty")
    local timeout=$(echo "$json_content" | jq -r ".timeout // \\"3000000\\"")
    
    # Validate required fields
    if [ -z "$api_key" ] || [ "$api_key" = "null" ]; then
        echo "Error: Invalid or missing API key in $config_file" >&2
        echo "Run 'cc-config provider edit $provider_alias' to set the API key" >&2
        return 1
    fi
    
    if [ -z "$base_url" ] || [ "$base_url" = "null" ]; then
        echo "Error: Invalid or missing base URL in $config_file" >&2
        echo "Run 'cc-config provider edit $provider_alias' to set the base URL" >&2
        return 1
    fi
    
    # Validate API key format (basic check)
    if [ \${#api_key} -lt 10 ]; then
        echo "Warning: API key appears to be too short" >&2
    fi
    
    # Validate URL format
    if ! echo "$base_url" | grep -qE '^https?://'; then
        echo "Warning: Base URL does not appear to be a valid HTTP(S) URL" >&2
    fi
    
    # Set environment variables
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    export ANTHROPIC_BASE_URL="$base_url"
    export API_TIMEOUT_MS="$timeout"
    
    # Update last used timestamp (optional, silent fail)
    if command -v cc-config >/dev/null 2>&1; then
        cc-config provider --update-last-used "$provider_alias" 2>/dev/null || true
    fi
    
    return 0
}

# Enhanced helper function to check if Claude CLI is available
_cc_check_claude_cli() {
    if ! command -v claude >/dev/null 2>&1; then
        echo "Error: Claude CLI not found in PATH" >&2
        echo "" >&2
        echo "Installation instructions:" >&2
        echo "  npm install -g @anthropic-ai/claude-code" >&2
        echo "" >&2
        echo "If already installed, check your PATH or restart your terminal" >&2
        return 1
    fi
    
    # Verify Claude CLI is working
    if ! claude --version >/dev/null 2>&1; then
        echo "Error: Claude CLI is installed but not working properly" >&2
        echo "Try reinstalling: npm uninstall -g @anthropic-ai/claude-code && npm install -g @anthropic-ai/claude-code" >&2
        return 1
    fi
    
    return 0
}


# Function to safely execute claude with error handling
_cc_claude_exec() {
    local provider_alias="$1"
    shift
    
    # Check prerequisites
    if ! _cc_check_claude_cli; then
        return 1
    fi
    
    # Ensure environment is clean before loading new config
    unset ANTHROPIC_AUTH_TOKEN ANTHROPIC_BASE_URL API_TIMEOUT_MS
    
    # Load provider configuration
    local config_file="\${CC_PROVIDERS_DIR:-~/.cc-config/providers}/$provider_alias.json"
    if ! _cc_load_config "$config_file" "$provider_alias"; then
        return 1
    fi
    
    # Execute claude with error handling
    if ! claude "$@"; then
        local exit_code=$?
        echo "Error: Claude command failed (exit code: $exit_code)" >&2
        echo "Provider: $provider_alias" >&2
        echo "Arguments: $*" >&2
        return $exit_code
    fi
    
    return 0
}`;
  }

  /**
   * Generate aliases for providers (internal method)
   */
  generateProviderAliases(providers) {
    if (providers.length === 0) {
      return `# No providers configured yet
# Run 'cc-config provider add' to add your first provider`;
    }

    const aliases = providers.map(provider => {
      return `# Provider: ${provider.alias} (${provider.baseURL})
alias ${provider.alias}='_cc_claude_exec "${provider.alias}"'`;
    }).join('\n\n');

    return `# Provider aliases
${aliases}`;
  }

  /**
   * Generate file footer
   */
  generateFooter(providers) {
    const providerList = providers.map(p => `#   ${p.alias}: ${p.baseURL}`).join('\n');
    const providerCount = providers.length;

    return `# Claude Code Kit Statistics
# Total providers configured: ${providerCount}
# Providers:
${providerList || '#   (none configured)'}
#
# Available commands:
${providers.map(p => `#   ${p.alias} "your message"     # Use ${p.alias} provider`).join('\n')}
#
# Management commands:
#   cc-config provider list     # List all providers
#   cc-config provider show <alias>  # Show provider details
#   cc-config provider add      # Add a new provider
#   cc-config status           # Show system status
#
# For more information: https://github.com/kedoupi/claude-code-kit

# Function to list all available Claude providers
claude-providers() {
    echo "Claude Code Kit - Available Providers:"
    echo "======================================"
    ${providers.map(p => `echo "  ${p.alias}: ${p.baseURL}"`).join('\n    ')}
    echo ""
    echo "Usage: <provider-name> \\"your message\\""
    echo "Example: ${providers[0]?.alias || 'claude'} \\"Hello, how are you?\\""
}

# Function to reload aliases after configuration changes
claude-reload() {
    source "$HOME/.cc-config/aliases.sh"
    echo "Claude Code Kit aliases reloaded"
}`;
  }

  /**
   * Validate alias name
   */
  validateAlias(alias) {
    // Check for valid alias format
    if (!/^[a-zA-Z0-9-_]+$/.test(alias)) {
      throw new Error('Alias can only contain letters, numbers, hyphens, and underscores');
    }

    // Check for shell reserved words
    const reservedWords = [
      'alias', 'bg', 'bind', 'break', 'builtin', 'caller', 'cd', 'command',
      'compgen', 'complete', 'compopt', 'continue', 'declare', 'dirs', 'disown',
      'echo', 'enable', 'eval', 'exec', 'exit', 'export', 'false', 'fc',
      'fg', 'getopts', 'hash', 'help', 'history', 'if', 'jobs', 'kill',
      'let', 'local', 'logout', 'mapfile', 'popd', 'printf', 'pushd',
      'pwd', 'read', 'readonly', 'return', 'set', 'shift', 'shopt',
      'source', 'suspend', 'test', 'times', 'trap', 'true', 'type',
      'typeset', 'ulimit', 'umask', 'unalias', 'unset', 'wait'
    ];

    if (reservedWords.includes(alias)) {
      throw new Error(`'${alias}' is a shell reserved word and cannot be used as an alias`);
    }

    // Check for common command conflicts
    const commonCommands = [
      'ls', 'cd', 'pwd', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'find',
      'grep', 'sed', 'awk', 'cat', 'less', 'more', 'head', 'tail',
      'sort', 'uniq', 'wc', 'diff', 'tar', 'gzip', 'curl', 'wget',
      'ssh', 'scp', 'rsync', 'git', 'npm', 'node', 'python', 'java'
    ];

    if (commonCommands.includes(alias)) {
      console.warn(`Warning: '${alias}' conflicts with a common command. Consider using a different alias.`);
    }
  }

  /**
   * Get alias statistics
   */
  async getStats() {
    const providers = await this.loadProviders();
    
    return {
      totalProviders: providers.length,
      aliases: providers.map(p => p.alias),
      baseURLs: [...new Set(providers.map(p => p.baseURL))],
      lastGenerated: await this.getLastGeneratedTime()
    };
  }

  /**
   * Get last generated timestamp
   */
  async getLastGeneratedTime() {
    try {
      if (!await fs.pathExists(this.aliasesFile)) {
        return null;
      }

      const stats = await fs.stat(this.aliasesFile);
      return stats.mtime;
    } catch {
      return null;
    }
  }

  /**
   * Check if aliases file is up to date
   */
  async isUpToDate() {
    try {
      const aliasesTime = await this.getLastGeneratedTime();
      if (!aliasesTime) {
        return false;
      }

      // Check if any provider file is newer than aliases file
      const files = await fs.readdir(this.providersDir);
      
      for (const file of files) {
        if (path.extname(file) === '.json') {
          const providerFile = path.join(this.providersDir, file);
          const providerStats = await fs.stat(providerFile);
          
          if (providerStats.mtime > aliasesTime) {
            return false;
          }
        }
      }

      return true;
    } catch {
      return false;
    }
  }

  /**
   * Preview aliases without writing to file
   */
  async previewAliases() {
    const providers = await this.loadProviders();
    return this.buildAliasContent(providers);
  }

  /**
   * Detect shell type for compatibility
   */
  _detectShell() {
    const shell = process.env.SHELL || 'unknown';
    
    if (shell.includes('zsh')) {
      return 'zsh';
    }
    if (shell.includes('bash')) {
      return 'bash';
    }
    if (shell.includes('fish')) {
      return 'fish';
    }
    if (shell.includes('dash')) {
      return 'dash';
    }
    
    return 'unknown';
  }

  /**
   * Acquire lock for alias operations
   */
  async _acquireLock(operation) {
    // Ensure config directory exists before checking lock
    await fs.ensureDir(this.configDir);
    
    if (await fs.pathExists(this.lockFile)) {
      const lockContent = await fs.readFile(this.lockFile, 'utf8').catch(() => '{}');
      try {
        const lock = JSON.parse(lockContent);
        const lockAge = Date.now() - new Date(lock.created).getTime();
        
        // If lock is older than 2 minutes, consider it stale
        if (lockAge > 2 * 60 * 1000) {
          await fs.remove(this.lockFile);
        } else {
          throw new Error(`Alias operation locked by ${lock.operation} since ${lock.created}`);
        }
      } catch (parseError) {
        await fs.remove(this.lockFile);
      }
    }

    const lockData = {
      operation,
      pid: process.pid,
      created: new Date().toISOString()
    };
    
    await fs.writeJson(this.lockFile, lockData);
  }

  /**
   * Release lock for alias operations
   */
  async _releaseLock() {
    if (await fs.pathExists(this.lockFile)) {
      await fs.remove(this.lockFile);
    }
  }

  /**
   * Validate providers for security issues
   */
  async _validateProviders(providers) {
    for (const provider of providers) {
      // Validate alias
      if (!provider.alias || typeof provider.alias !== 'string') {
        throw new Error(`Invalid provider alias: ${provider.alias}`);
      }
      
      if (provider.alias.length > this.maxAliasLength) {
        throw new Error(`Provider alias too long: ${provider.alias} (max ${this.maxAliasLength} chars)`);
      }
      
      // Check for shell injection attempts
      if (provider.alias.includes(';') || provider.alias.includes('|') || 
          provider.alias.includes('&') || provider.alias.includes('`') ||
          provider.alias.includes('$') || provider.alias.includes('(') ||
          provider.alias.includes(')')) {
        throw new Error(`Provider alias contains potentially dangerous characters: ${provider.alias}`);
      }
      
      // Validate using existing method
      this.validateAlias(provider.alias);
    }
  }

  /**
   * Backup existing aliases file
   */
  async _backupExistingAliases() {
    if (await fs.pathExists(this.aliasesFile)) {
      const backupFile = `${this.aliasesFile}.backup-${Date.now()}`;
      await fs.copy(this.aliasesFile, backupFile);
      
      // Keep only the 3 most recent backups
      const backupPattern = `${this.aliasesFile}.backup-`;
      const dir = path.dirname(this.aliasesFile);
      const files = await fs.readdir(dir);
      
      const backupFiles = files
        .filter(file => file.startsWith(path.basename(backupPattern)))
        .map(file => ({
          name: file,
          path: path.join(dir, file),
          time: parseInt(file.split('-').pop()) || 0
        }))
        .sort((a, b) => b.time - a.time);
      
      // Remove old backups
      for (const backup of backupFiles.slice(3)) {
        await fs.remove(backup.path).catch(() => {});
      }
    }
  }

  /**
   * Verify the generated aliases file
   */
  async _verifyAliasesFile() {
    if (!await fs.pathExists(this.aliasesFile)) {
      throw new Error('Aliases file was not created');
    }
    
    const content = await fs.readFile(this.aliasesFile, 'utf8');
    
    // Basic validation
    if (content.length === 0) {
      throw new Error('Generated aliases file is empty');
    }
    
    if (!content.includes('Claude Code Kit')) {
      throw new Error('Generated aliases file does not contain expected header');
    }
    
    // Check for potential shell injection
    const dangerousPatterns = [
      /;\s*rm\s+/g,
      /;\s*sudo\s+/g,
      /\|\s*sh\s*$/g,
      /`[^`]*rm[^`]*`/g,  // More specific - only flag backticks with rm
      /\$\([^)]*rm[^)]*\)/g  // More specific - only flag command substitution with rm
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(content)) {
        throw new Error(`Generated aliases file contains potentially dangerous content`);
      }
    }
  }

  /**
   * Get enhanced statistics including shell compatibility
   */
  async getEnhancedStats() {
    const basicStats = await this.getStats();
    
    return {
      ...basicStats,
      shellType: this.shellType,
      shellCompatible: this.shellType !== 'unknown',
      version: this.version,
      security: {
        maxAliasLength: this.maxAliasLength,
        validationEnabled: true
      },
      file: {
        path: this.aliasesFile,
        exists: await fs.pathExists(this.aliasesFile),
        upToDate: await this.isUpToDate(),
        size: await this._getFileSize()
      }
    };
  }

  /**
   * Get aliases file size
   */
  async _getFileSize() {
    try {
      if (!await fs.pathExists(this.aliasesFile)) {
        return 0;
      }
      const stats = await fs.stat(this.aliasesFile);
      return stats.size;
    } catch {
      return 0;
    }
  }
}

module.exports = AliasGenerator;